<?php
// for FMediaFile

// greatest dimensions smaller or equal to original (will keep aspect ratio)
define('IMAGE_RESIZE_FIT', 0);
// similar to IMAGE_RESIZE_FIT, but adds transparent stripes
define('IMAGE_RESIZE_PAD', 1);
// will strech the image, does not keep aspect ratio
define('IMAGE_RESIZE_STRECH', 2);



/**
 *  @todo: fix default and automatic values
 * FIXME : check parameter types. Some functions expect some parameters to be Models, while they probably should be IModels 
 */
/**
 * Source of the messages. This interface was developed for field validation errors messages. In this case fields and their 
 * validation rules are defined during model creation. Sometimes one may want to define field-specific validation error 
 * messages at the same time, while in other cases a single, central (i.e. db-based) source of messages is required. 
 * With this interface preventing direct usage of arrays one can easier abstract from the exact source of the messages. 
 */
interface IMessageSource
{

    /**
     * Retrieves a message based on the calling object and message id.
     * @param $caller the calling object
     * @param $id message id. I.e. in case of validation error messages the message id is the name of a validation rule. 
     * @return The message string or NULL if no message was found.
     */
    public function get($caller, $id);

    /**
     * Sets a message based on calling object and message id.
     * @param $caller the calling object
     * @param $id message id. I.e. in case of validation error messages the message id is the name of a validation rule. 
     * @param $value if null given -- $id is expected to be an associative array with messages
     * @return previous value, if $value was null -- all messages may be returned
     */
    public function set($caller, $id, $value = null);
}

/**
 * A typical, array based source of messages.
 * This Message source is comonly used by fields. For instance Model::mess() method creates a MessageArray if it's given
 * an array of messages. One may decide to use a single messages source for every field of a model. 
 */
class MessageArray implements IMessageSource
{
    protected $_mess;

    public function __construct(array $messages)
    {
        $this->_mess = $messages;
    }

    public function get($caller, $id)
    {
        return (@$this->_mess[$id]);
    }

    /**
     * @author m.augustynowicz
     */
    public function set($caller, $id, $value = null)
    {
        if(null !== $value)
        {
            $prev = $this->get($caller, $id);
            $this->_mess[$id] = $value;
        }
        else
        {
            $prev = $this->_mess;
            $this->_mess = array_merge($this->_mess, $id);
        }
        return $prev;
    }
}

/**
 * Interface of a field. A field is an abstraction of a scalar value in the SQL 
 * query. The part of a sql statement that generates a scalar value is returned by 
 * the generator() method. A group of scalar values originating in a model (a specific 
 * collumn of a table) is further specified by the IModelField interface.
 * Keep in mind that the type of a specific IField object is not the same as the type
 * of its generator(). This is distinguished to allow creation of a single IField that
 * supports mutliple types. An example of such class is FConst, that keeps a constant value of
 * one of multiple types. Use type() function to determine the generator type.
 */
interface IField
{

    /**
     * Returns a part of SQL statement, that generates field value.
     * Ie., in case of a data model this function returns simply field name. However a field may have a complex definition,
     * that uses functions (possibly aggregate) and operators to generate its value.
     * @return string Field generating expression.
     */
    public function generator();

    /**
     * Is expected to call generator()
     */
    public function __toString();

    /**
     * Evaluates the value of field with the current data.
     * @param $data Associative array of Models.
     */
    //public function evaluate();
    /**
     * Returns type of the generator.
     * @param $is string If given, function checks if generator is of this type, or of one of decendant types.
     * @return mixed If $is is given, the function returns true if the types match, false otherwise. If $is is 
     *     left blank, then string with generator type class name is returned (name of IField implementator)
     */
    public function type($is = '');
}

/**
 * Interface of fields generated by table columns.
 */
interface IModelField extends IField
{

    /**
     * Returns a source model of this field. 
     * @return object A model from which this field comes from, or NULL if there is no source model.
     */
    //    public function sourceModel();
    /**
     * Retrieves the name of model field.
     * Which is the same as both column name and result of generator()
     */
    public function getName();

    /**
     * Defines validation rules. Set of acceptable rules depends on field type. 
     * @param $rules array If provided, the new set of validation rules replaces existing one. 
     *      If not provided, the function returns current rules set.
     * @return array If $rules is not provided, the array if rules is returned.
     */
    public function rules($rules = NULL);

    /**
     * Checks if provided type definition matches definition of the Field
     * @param $def array with keys fieldname, typename, type_specific, notNull, defval. See the implementation of Model::checkDbType() for details.
     * @return mixed boolean false if types match, the array of non-matching elements of $def if something is wrong.
     */
    public function checkType($def);

    /**
     * Checks if the given value is valid according to the generator type and set of validation rules.
     * @param $value A value to be checked. If the field has an automatic value property, then the automatic value is given.
     * @result int 0 if the value is valid, or a non-0 error code
     */
    public function invalid(&$value);

    /**
     * Returns a string with data base declaration of generators type.
     */
    public function dbType();

    /**
     * Sets or retrieves the source model of a field. 
     * @param $owner a model to set as a source
     * $return if a $model is not given, the current source model is returned.
     */
    public function sourceModel(Model $model = NULL);

    /**
     * Prepare string to be concatenated with SQL query string.
     * @param mixed $value
     * @return string
     */
    public function dbString($value);


    public function columnDefinition();
    public function columnDefinitionAdditionalQuery();
}

/**
 * Complex fields, that evaluate from other IFields.
 * Their generate() function will typically return an expression containing operators,
 * function calls and, generally - other fields.
 */
interface IEvalField extends IField
{
}

/**
 * Interface of all fields that evaluates to bool. These kind of fields are widely used
 * by datasets to define conditions of joining ( JOIN x ON (IBoolean::generator()) and filters (WHERE (IBoolean::generator()))
 */
interface IBoolean extends IField
{
}

/**
 * A abstract base of many  types, that generate IBoolean. 
 * Created only to implement the type function.
 */
abstract class FCustomBoolean implements IBoolean
{

    /**
     * Either checks if the given type implements IBoolean, or returns IBoolean.
     * @param $is A type to check.
     * @return If $is is not given, the function returns generator type, in this case 'IBoolean'.
     */
    public function type($is = '')
    {
        if(!empty($is))
        {
            if($is == 'IBoolean' || in_array('IBoolean', class_implements($is)))
                return (true);
            return (false);
        }
        return ('IBoolean');
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * A abstract base of fields that have variable generator type.
 * Implements type function
 */
abstract class FAnyType implements IField
{
    protected $_genType;

    /**
     * Either checks if the given type matches the current generator type of FAnyField,
     * or returns the current generator type.
     * @param $is a type to check
     * @return if $is is not given, the current generator type is returned.
     */
    public function type($is = '')
    {
        if(!empty($is))
        {
            if($is == $this->_genType || is_subclass_of($this->_genType, $is) || in_array($is, class_implements($this->_genType)))
                return (true);
            return (false);
        }
        return ($this->_genType);
    }

    /**
     * experimental function to generate the most adequate IField from the given parameter
     */
    public static function factory($source)
    {
        if(in_array(gettype($source), array(
            "boolean",
            "integer",
            "double",
            "float",
            'string'
        )))
            return new FConst($source);
        throw new HgException('factory failed');
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * Constant values
 */
class FConst extends FAnyType implements IField
{
    protected $_value;

    public function __construct($value, $type = '')
    {
        $this->_value = $value;
        if(empty($type))
        {
            switch(gettype($value))
            {
                case "boolean":
                    $this->_genType = 'FBool';
                break;
                case "integer":
                    $this->_genType = 'FInt';
                break;
                case "double":
                case "float":
                    $this->_genType = 'FFloat';
                break;
                case "string":
                    $this->_genType = 'FString';
                break;
                case "NULL":
                    $this->_genType = 'FNull';
                break;
                /*"array"
                "object"
                "resource"*/
            }
        }
        else
        {
            if(!is_subclass_of($type, 'IField'))
                throw new HgException('$type has to be a class name of an IField descendant.');
            $this->_genType = $type;
        }
    }

    /**
     * Directly returns value of the constant.
     * @return The constants value.
     */
    public function generator()
    {
        if($this->_genType == 'FString')
            return ("'{$this->_value}'");
        elseif($this->_genType == 'FNull')
            return 'NULL';
        else
            return ($this->_value);
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * Only for the NULL value
 */
class FNull extends FAnyType implements IField
{

    /**
     * @return The 'NULL' string.
     */
    public function generator()
    {
        return 'NULL';
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * A common base class for most ModelFields.
 */
abstract class Field implements IModelField
{
    protected $_name; //!< Field name, alias of the column in the query
    protected $_rules; //!< validation rules
    protected $_mess = null; //!< Message source with messages to use for validation errors.
    protected $_model = NULL;

    /**
     * Returns the column name with model alias.
     * @return If the model doesn't have an alias - a column name is returned. If the alias
     *    is present, then a string "$alias.$model" is returned.
     */
    public function generator()
    {
        $alias = $this->_model->alias();
        if(!empty($alias))
            $alias = "\"$alias\".";
        if($this->_model)
            return ("{$alias}\"{$this->_name}\"");
        return ($this->_name);
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }

    /**
     * Field constructor
     * @param $name Fields name.
     * @param $notnull Null/not null property.
     * @param $def_value Default value of the field.
     */
    public function __construct($name, $notnull = false, $def_val = null)
    {
        $this->_name = $name;
        $this->_rules['notnull'] = $notnull;
        if($def_val!==null)
            $this->auto('DEFAULT');
        $this->_rules['defval'] = $def_val;
        $this->mess(array('invalid' => 'Invalid value'));
    }

    /**
     * Field name getter.
     * @return the field name.
     */
    public function getName()
    {
        return ($this->_name);
    }

    /**
     * Evaluates the field value. This should pull the value from the model.
     */
    /*
    public function evaluate()
    {
        return($this->sourceModel()->valueOf($this->_name));
    }    
    */
    /**
     * Checks or retrieves generator() type. In case of Fields a generator type
     * and object type are considered the same.
     * @param $is A type to check.
     * @return if $is is given, then a boolean value is returned that says if 
     *     fields type and is match. If $is is not given, generator type is returned (get_class($this))
     */
    public function type($is = '')
    {
        if(!empty($is))
        {
            if($this instanceof $is || in_array($is, class_implements($this)))
                return (true);
            return (false);
        }
        return (get_class($this));
    }

    /**
     * Sets or retrieves validation rules. 
     * @param $rules array of rules to set.
     * @return if $rules is not given, the current rules set is returned, else - the new rules are set, and field object is returned to allow chaining
     * @TODO : allow more flexible set of parameters i. e. $f->rules('length>',12) adds a single rule
     */
    public function rules($rules = NULL)
    {
        if(NULL === $rules)
            return ($this->_rules);
        elseif(is_array($rules))
        {
            //$this->_rules = array_filter(array_merge($this->_rules,$rules),array($this,'_filterNulls'));
            $this->_rules = array_merge($this->_rules, $rules);
            return ($this);
        }
        else
            throw new HgException("Invalid value type, array expected");
    }

    /**
     * Sets or retrieves validation error messages source.
     * @param $mess Either NULL, or an array with keys named after validation rules and values keeping messages to use 
     *     when data fails to validate with that rule. $mess can also be an IMessageSource object. In fact, the array
     *     will by converted to a MessageArray. 
     * @return If $mess is NULL, the current IMessageSource is returned. Otherwise $this is returned to allow chaining. 
     */
    public function mess($mess = NULL)
    {
        if(NULL === $mess)
            return $this->_mess;

        if(null === $this->_mess)
            $this->_mess = new MessageArray($mess);
        else
            $this->_mess->set($this, $mess);

        return $this;
    }

    /**
     * Sets or retrieves field's automatic value property. When the field is automatic, then the value passed to the
     * dbString() is always ignored, and the value provided by $source is returned. 
     * @param $source Can be:
     *  * a callback to a function that returns the automatic value. In this case $args holds optional arguments to 
     *    pass with the call. Any array is considered to be a callback.
     *  * an IField, for wchich the IField::generator() will be passed. $args is ignored.
     *  * A boolean value. Will be converted to either true or false (without quotes).
     *  * Any other non-array value will be converted to a string and directly pasted into the query. 
     * @param boolean $quote quote value returned by source
     */
    public function auto($source = null, $quote = true)
    {
        if (0 === func_num_args())
        {
            return isset($this->_rules['auto']) ? $this->_rules['auto'] : null;
        }

        $this->_rules['auto'] = array(
            'source' => & $source,
            'quote'  => $quote
        );
        return $this;
    }

    /**
     * Generates automatic value of a field.
     * @author p.piskorski
     * @author m.augustynowicz passing $value by reference, returning boolean
     *
     * @param string $action insert or update
     * @param mixed $value original value, may be modified
     * @return boolean whether automatic value has been assigned to $value
     */
    public function autoValue($action=null, & $value=null)
    {
        $value_given = func_num_args() >= 2;

        if (isset($this->_rules['auto']))
        {
            $def = & $this->_rules['auto'];

            switch (true)
            {
                // DEFAULT
                case 'DEFAULT' === $def['source'] :
                    if (null === $action || 'update' === $action)
                        return false;
                    if ($this->_rules['notnull'] && null === $value)
                    {
                        $value = $this->defaultValue();
                        if (null === $value)
                        {
                            throw new HgException("Automatic uses default value that is not set");
                        }
                        $value = $this->dbString($value);
                    }
                    else
                        return false;
                    break;

                // sync with another field
                case $def['source'] instanceof IField :
                    $value = $def['source']->generator();
                    break;

                // use callback
                case is_array($def['source']) :
                    $new_value = call_user_func($def['source'],
                            $action, $this, $value);
                    if (null === $new_value)
                    {
                        return false;
                    }
                    if ($def['quote'])
                    {
                        $value = $this->dbString($new_value);
                    }
                    else
                    {
                        $value = $new_value;
                    }
                    break;

                // use the literal value
                default :
                    $value = $def['source'];
                    if ($def['quote'])
                    {
                        $value = $this->dbString($value);
                    }
            }
            return true;
        }
        return false;
    }


    /**
     * Sets or retrieves not null property
     * @param $notnull a boolean true or false to set the not null property
     * @return if $notnull is not given, or is not a boolean - current value of the property is returned, or NULL if the property wasn't set.
     */
    public function notNull($notnull = NULL)
    {
        if(is_bool($notnull))
            $this->_rules['notnull'] = $notnull;
        else
            return (isset($this->_rules['notnull']) ? $this->_rules['notnull'] : NULL);
    }

    /**
     * Sets or retrieves the default value.
     */
    public function defaultValue($def_val = '')
    {
        if('' !== $def_val)
        {
            $this->_rules['defval'] = $def_val;
            $this->auto('DEFAULT');
        }
        else
            return (isset($this->_rules['defval']) ? $this->_rules['defval'] : '');
    }

    /**
     * Sets or retrieves field's source model.
     * @param $model A model to set as a field's source, or NULL to retrieve current source model.
     * @return The field's source model as long as $model is NULL (default).
     */
    public function sourceModel(Model $model = NULL)
    {
        if($model)
            $this->_model = $model;
        else
            return ($this->_model);
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            return pg_escape_string($value);
        }
    }

    public function columnDefinition()
    {
        $sql = '"' . $this->getName() . '" ' . $this->dbType();

        if ($this->notNull())
        {
            $sql .= ' NOT NULL';
        }

        $def = $this->defaultValue();
        if (null !== $def)
        {
            $sql .= ' DEFAULT ' . $this->dbString($def);
        }

        return $sql;
    }

    public function invalid(&$value)
    {
        if(NULL === $value && $this->notNull())
        {
            if(!isset($this->_rules['auto']) && !isset($this->_rules['defval']))
                return ('notnull');
        }
        return (false);
    }

    public function checkType($def)
    {
        $res = array();

        // column type

        $type = $this->dbType();
        $type = strtolower($type);
        $db_type = $def['typename'];
        $db_type = strtolower($db_type);
        $db_type_with_size = sprintf('%s(%s)', $db_type, @$this->_rules['max_length']);

        if ($type != $db_type)
        if ($type != $db_type_with_size)
        {
            $res['typename'] = $this->dbType();
        }

        // NOT NULL

        $v = 'f';
        if(isset($this->_rules['notnull']))
            $v = ($this->_rules['notnull'] === true ? 't' : 'f');
        if($def['notnull'] != $v)
            $res['notnull'] = $v;

        // DEFAULT

        $v = @$this->_rules['defval'];
        if (null !== $v)
        {
            $v = $this->dbString($v);
        }
        $ds_type = strtolower($this->dbType());
        // stand alone value
        if ($v !== $def['defval'])
        {
            // casted value
            if ($v.'::'.$type !== $def['defval'])
                // casted value with quoted type
                if ($v.'::"'.$type.'"' !== $def['defval'])
                    $res['defval'] = $v;
        }

        return empty($res) ? false : $res;
    }

    protected function _errors(&$error, &$value)
    {
        if($tmp = self::invalid($value))
            $error[$tmp] = true;
        if(empty($error))
            return (false);
        if(NULL !== $this->_mess)
        {
            foreach($error as $rule => &$code)
            {
                if(NULL !== ($m = $this->_mess->get($this, $rule)))
                    $code = $m;
                else
                    $code = $this->_mess->get($this, 'invalid');
            }
        }
        return (g()->first_controller->trans($error));
    }

    protected function _filterNulls($val)
    {
        return ($val !== NULL);
    }


    /**
     * Additional query that should be run before creating table with this field
     * @author m.augustynowicz
     *
     * @return boolean|string sql query to run or false, when nothing is necesary
     */
    public function columnDefinitionAdditionalQuery()
    {
        return false;
    }
}

/**
 * A string field.
 */
abstract class FStringBase extends Field
{
    /**
     * Field constructor
     * @param $name Fields name.
     * @param $notnull Null/not null property.
     * @param $def_value Default value of the field.
     */
    public function __construct($name, $notnull = false, $def_val = null, $min_length = null, $max_length = null)
    {
        parent::__construct($name, $notnull, $def_val);
        $this->_rules['min_length'] = $min_length;
        $this->_rules['max_length'] = $max_length;
        $this->mess(array(
            'max_length' => 'Value too long',
            'min_length' => 'Value too short',
            'notnull' => 'Field required'
        ));
    }

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] == 'text')
        {
            if($def['type_specific'] != '-1' && !isset($this->_rules['max_length']))
                $res['typename'] = $this->dbType();
        }
        elseif($def['typename'] == 'varchar' || $def['typename'] == 'bpchar')
        {
            if(!g('Functions')->isInt($def['type_specific']) || $def['type_specific'] - 4 < $this->_rules['min_length'] || $def['type_specific'] - 4 > $this->_rules['max_length'])
                $res['typename'] = $this->dbType();
        }
        else
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            $value = str_replace("\r\n", "\n", $value);
            $length = mb_strlen($value, 'utf-8');
            //null is not the same as an empty string
            //if(isset($this->_rules['notnull']) && $this->_rules['notnull'] && !$length)
            //  return true;
            if(isset($this->_rules['min_length']) && $this->_rules['min_length'] > $length)
                $err['min_length'] = true;
            if(isset($this->_rules['max_length']) && $this->_rules['max_length'] < $length)
                $err['max_length'] = true;
        }
        return ($this->_errors($err, $value));
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            return "'" . str_replace("\n",'\n',pg_escape_string($value)) . "'";
        }
    }

    public function dbType()
    {
        if (isset($this->_rules['max_length']))
        {
            if ($this->_rules['max_length'] === @$this->_rules['min_length'])
                return "BPCHAR({$this->_rules['max_length']})";
            else
                return "VARCHAR({$this->_rules['max_length']})";
        }
        else
            return 'TEXT';
    }
}


/**
 * Generic, one-line text
 * @todo strip/entity tags
 * @todo strip new lines
 * @author m.augustynowicz
 */
class FString extends FStringBase
{
    public function dbString($value)
    {
        if (null  !== $value)
        if (false !== $value)
        if (''    !== $value)
        {
            $value = htmlspecialchars($value);
            $value = strtr($value, array("\n"=>'', "\r"=>''));
        }
        return parent::dbString($value);
    }
}


/**
 * Multiline HTML
 * @author m.augustynowicz
 */
class FRich extends FStringBase
{
}


/**
 * Multiline text
 * @todo strip/entity tags
 * @author m.augustynowicz
 */
class FMultilineString extends FStringBase
{
    public function dbString($value)
    {
        if (null  !== $value)
        if (false !== $value)
        if (''    !== $value)
        {
            $value = htmlspecialchars($value);

        }
        return parent::dbString($value);
    }
}


/**
 * A woman field. 
 */
class FEmail extends FString
{
    public function __construct($name, $notnull = false, $def_val = null)
    {
        parent::__construct($name, $notnull, $def_val, 3, 320);
        $this->mess(array(
            'invalid' => 'Invalid e-mail address'
        ));
    }

    public function rules($rules = NULL)
    {
        if(isset($rules['max_length']) && $rules['max_length'] > 320)
            $rules['max_length'] = 320;
        if(isset($rules['min_length']) && $rules['min_length'] < 3)
            $rules['min_length'] = 3;
        return (parent::rules($rules));
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            if($tmp = parent::invalid($value))
                $err = $tmp;
            if(!self::isEmail($value))
                $err['invalid'] = true;
            $length = strlen($value);
        }
        return ($this->_errors($err, $value));
    }

    static function isEmail($text)
    {
        return (g('Functions')->checkEmail($text));
    }
}

class FMD5String extends FString
{

    public function __construct($name, $notnull = false, $min_length = 32, $max_length = 32)
    {
        parent::__construct($name, $notnull, null, $min_length, $max_length);
    }
}

class FPassword extends FMD5String
{

    public function __construct($name, $min_length = null, $max_length = null, $notnull = true)
    {
        parent::__construct($name, $notnull, $min_length, $max_length);
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            // it's query-safe
            return "'" . md5($value) . "'";
        }
    }
}

/**
 * String with a url.
 * @author m.augustynowicz
 */
class FURL extends FString
{
    protected $_allowed_protocols = array();
    protected $_default_protocol = '';
    protected $_check_dns_records = false;

    public function __construct($name, $notnull = false, $def_val = null, $min_length = null, $max_length = null, $allowed_protocols=array('http','https','ftp','gopher'), $default_protocol='http', $check_dns_records=array('ANY'))
    {
        $this->_allowed_protocols = array_flip($allowed_protocols);
        $this->_default_protocol = $default_protocol;
        $this->_check_dns_records = $check_dns_records;
        parent::__construct($name, $notnull, $def_val, $min_length, $max_length);
        $this->mess(array(
            'unsupported protocol' => 'Unsupported protocol',
            'syntax error' => 'Incorrect URL',
            'no dns record' => 'Invalid host name',
        ));
    }

    public function invalid(&$value)
    {
        $err = parent::invalid($value);
        $value = trim($value);

        if(($this->notNull() && NULL !== $value) || (!$this->notNull() && $value != NULL))
        {
            if (!preg_match('!^([a-zA-Z]+)://!', $value, $matches))
                $value = $this->_default_protocol . '://' . $value;
            else if (!isset($this->_allowed_protocols[$matches[1]]))
                $err['unsupported protocol'] = true;

            if (!preg_match('!^[a-zA-Z]+://([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+)(?:\/|$)!', $value, $matches))
                $err['syntax error'] = true;

            if (!function_exists('checkdnsrr'))
            {
                if (g()->debug->allowed())
                    g()->addInfo('checkdnsrr not available', 'debug', 'PHP function checkdnsrr() is not available!');
            }
            else if ($this->_check_dns_records)
            {
                foreach ($this->_check_dns_records as $dnsr)
                {
                    if (!checkdnsrr($matches[1].'.', $dnsr))
                    {
                        $err['no dns record'] = true;
                        break;
                    }
                }
            }
        }

        return $this->_errors($err, $value);
    }
}

/**
 * String with a http url.
 * @author m.augustynowicz
 */
class FHTTP extends FURL
{
    public function __construct($name, $notnull = false, $def_val = null, $min_length = null, $max_length = null)
    {
        return parent::__construct($name, $notnull, $def_val, $min_length, $max_length, array('http','https'), 'http');
    }
}

/**
 * Coordinates with location on the globe.
 * @author m.augustynowicz
 */
class FLocationCoords extends Field
{
    /**
     * Invalidate value submitted by user.
     * Accepts string with pair of floats (surrounded by brackets or not)
     * and array with two floats under [0] and [1] keys.
     * @param mixed $value (reference)
     * @return array field errors array
     */
    public function invalid(&$value)
    {
        $err = array();
        // handle null value
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
            return $this->_errors($err, $value);
        }

        if (!is_array($value))
        {
            $value = trim($value);
            if (!preg_match('/^\(?(-?[0-9]*\.?[0-9]*),(-?[0-9]*\.?[0-9]*)\)?$/', $value, $matches))
                $value = false; // awww.. syntax error ;(
            else
                $value = array($matches[1], $matches[2]);
        }

        if (!isset($value[0]) || !isset($value[1]))
        {
            $err['syntax error'] = true;
        }
        else
        {
            $f = g('Functions');
            $value[0] = $f->floatVal($value[0], true); // locale-unaware
            $value[1] = $f->floatVal($value[1], true); // locale-unaware
            if (false === $value[0] || false === $value[1])
            {
                $err['syntax error'] = true;
            }
            else
            {
                $value = sprintf('(%s,%s)', $value[0], $value[1]);
            }
        }

        if ($parent_err = parent::invalid($value))
            $err = array_merge($parent_err, $err);

        return ($this->_errors($err, $value));
    }

    /**
     * sql type
     */
    public function dbType()
    {
        return 'POINT';
    }

    /**
     * In addition to SQL value, fetch latituted and longitude in separate keys.
     * (with __lat and __lon suffixes)
     */
    public function generator()
    {
        $code = parent::generator();
        $code .= sprintf(', %s[0] AS "%s__lat"', parent::generator(), $this->_name);
        $code .= sprintf(', %s[1] AS "%s__lon"', parent::generator(), $this->_name);

        return $code;
    }
}

/**
 * A integer field.
 */
class FInt extends Field
{

    /**
     * Constructor.
     * @param $name field name
     * @param $precision byte-length of the field. Either 2, or 4, or 8. Any other value is treated as 4.
     * @param $notnull a not null property
     * @param $def_val A default value of the field.
     */
    public function __construct($name, $precision = 4, $notnull = false, $def_val = null)
    {
        parent::__construct($name, $notnull, $def_val);
        if(!in_array($precision, array(
            2,
            4,
            8
        )))
            $precison = 4;
        $this->_rules['precision'] = $precision;
    }

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] != 'int' && $def['typename'] != 'int' . $this->_rules['precision'])
            $res['typename'] = $this->dbType();
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();

        // note that this will cast $value to string
        $value = preg_replace('/ /', '', $value);

        if ('' !== $value)
        {
            if (!g('Functions')->isInt($value))
                $err['invalid'] = true;
        }
        else
        {
            if ($this->notNull())
                $err['notnull'] = true;
        }

        return ($this->_errors($err, $value));
    }

    public function dbType()
    {
        switch($this->_rules['precision'])
        {
            case 2:
                return ('INT2');
            break;
            case 4:
                return ('INT4');
            break;
            case 8:
                return ('INT8');
            break;
        }
    }

    public function dbString($value)
    {
        /*
        if(false !== ($av = @$this->autoValue()))
            return ($av);
         */
        if($value === null || $value === '')
            return "NULL";
        else
            return (pg_escape_string((int)$value));
    }

}


/**
 * Enumeration field
 *
 * Enumerations are defined in {@uses $conf[enum]}
 * @author m.augustynowicz
 */
class FEnum extends Field
{
    protected $_type_name = null;
    protected $_values = array();


    public function __construct($name, $type_name, $notnull=false, $default_value=null)
    {
        $enums = & g()->conf['enum'];

        if (!array_key_exists($type_name, $enums))
        {
            throw new HgException('Tried to create '.__CLASS__.' with non-existing enum `'.$type_name.'\'. Create one in conf[enum].');
        }

        parent::__construct($name, $notnull, $default_value);

        $this->_type_name = $type_name;
        $this->_values = & $enums[$type_name];

        if (empty($this->_values))
        {
            throw new HgException('Cannot create enum `'.$type_name.'\' as it has no values');
        }
    }


    public function invalid(&$value)
    {
        $err = array();

        if (false === array_search($value, $this->_values))
        {
            $err['invalid'] = true;
        }

        if (empty($err))
        {
            return parent::invalid($value);
        }
        else
        {
            return $this->_errors($err, $value);
        }
    }


    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            return "'" . str_replace("\n",'\n',pg_escape_string($value)) . "'";
        }
    }


    public function checkType($def)
    {
        $res = parent::checkType($def);

        if (isset($res['typename']))
        {
            $res['typename'] = '"' . $res['typename'] . '"';
        }

        if (isset($res['defval']))
        {
            $res['defval'] .= '::' . $this->_type_name;
        }
        return $res;
    }


    public function dbType()
    {
        return $this->_type_name;
    }


    /**
     * Part of SQL query used when creating 
     * @author m.augustynowicz
     */
    public function columnDefinition()
    {
        $sql = '"' . $this->getName() . '" "' . $this->dbType() . '"';

        if ($this->notNull())
        {
            $sql .= ' NOT NULL';
        }

        $def = $this->defaultValue();
        if (null !== $def)
        {
            $sql .= ' DEFAULT ' . $this->dbString($def);
        }

        return $sql;
    }


    /**
     * SQL query to be executed before creating model with that field
     * @author m.augustynowicz
     * @todo check whether type already exist
     */
    public function columnDefinitionAdditionalQuery()
    {
        static $type_exists = array();
        $checking_query = sprintf('SELECT COUNT(1) from pg_type WHERE typname = \'%s\'', pg_escape_string($this->_type_name));
        if(! g()->db->getOne($checking_query) && !@$type_exists[$this->_type_name])
        {
            $type_exists[$this->_type_name] = true;
            $sql_values = "'".join("','", $this->_values)."'";
            return sprintf('CREATE TYPE "%s" AS ENUM (%s)',
                    $this->_type_name, $sql_values );
        }
        else
            return false;
    }
}


/**
 * A floating point type.
 */
class FFloat extends Field
{

    /**
     * Constructor.
     *
     * @author ?
     * @author m.augustynowicz added {max,min} value and max decimals
     *
     * @param string $name field name
     * @param int $precision byte-length of the field.
     *        Either 2, or 4, or 8. Any other value is treated as 4.
     * @param boolean $notnull a not null property
     * @param null|float $def_val A default value of the field.
     * @param null|float $min_val minimal value
     * @param null|float $max_val maximal value
     * @param null|int $max_decimals maximum number of decimals after the point
     */
    public function __construct($name, $precision = 4, $notnull = false, $def_val = null, $min_val=null, $max_val=null, $max_decimals = null)
    {
        parent::__construct($name, $notnull, $def_val);

        if ($precision != 4 && $precision != 8)
            $precison = 4;
        $this->_rules['precision'] = $precision;

        $this->_rules['min_val'] = $min_val;
        $this->_rules['max_val'] = $max_val;
        $this->_rules['max_decimals'] = $max_decimals;

        $this->mess(array('invalid' => 'Invalid floating point value'));
        $this->mess(array('min_val_excided' => 'Number is to small'));
        $this->mess(array('max_val_excided' => 'Number is too big'));
        $this->mess(array('max_decimals_excided'
                => 'Too many digits after decimal point') );
    }

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] != 'float' && $def['typename'] != 'float' . $this->_rules['precision'])
            $res['typename'] = $this->dbType();
        else
            unset($res['typename']);
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            $value = g('Functions')->floatVal($value);
            if (false === $value)
                $err['invalid'] = true;
            if (null !== $this->_rules['min_val'])
            {
                if ($value < $this->_rules['min_val'])
                    $err['min_val_excided'] = true;
            }
            if (null !== $this->_rules['max_val'])
            {
                if ($value > $this->_rules['max_val'])
                    $err['max_val_excided'] = true;
            }
            if (null !== $this->_rules['max_decimals'])
            {
                $decimals = $value - (int)$value;
                $decimals_no = strlen((string) $decimals_no) - 2;
                if ($decimals_no > $this->_rules['max_decimals'])
                    $err['max_decimals_excided'] = true;
            }
        }

        return ($this->_errors($err, $value));
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            // it's query-safe
            return g('Functions')->floatVal($value, true);
        }
    }

    public function dbType()
    {
        switch($this->_rules['precision'])
        {
            case 4:
                return ('REAL');
                break;
            case 8:
                return ('DOUBLE PRECISION');
                break;
            default :
                throw HgException('Tried to create floating point field with unknow precision: '.
                            print_r($this->_rules['precision'], true) );
                break;
        }
    }
}

/**
 * Floting point type with secified number of digits after decimal separator.
 * min and max value can be defined
 * @author b.matuszewski
 */
class FDouble extends FFloat
{

    /**
     * Constructor.
     * @param $name field name
     * @param $precision byte-length of the field. Either 2, or 4, or 8. Any other value is treated as 8.
     * @param $notnull a not null property
     * @param $def_val A default value of the field.
     * @param int $decimal_places - number of digits after decimal separator (. or ,)
     * @param float $min_val - minimum value of a field
     * @param float $max_val - maximum value of a field
     */
    public function __construct($name, $precision = 8, $notnull = false, $def_val = null, $decimal_places = null, $min_val = null, $max_val = null)
    {
        parent::__construct($name, $precision, $notnull, $def_val, $min_val, $max_val);
        $this->_rules['decimal_places'] = $decimal_places;
        $this->mess(array('invalid' => 'Invalid floating point value'));
        $this->mess(array('min_val_excided' => 'Number is too small'));
        $this->mess(array('max_val_excided' => 'Number is too big'));
        $this->mess(array('dec_places_excided' =>
                'Too many numbers after decimal point' ));
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            $value = preg_replace('/,/','.',$value);
            if (!g('Functions')->areFloats($value))
            {
                $err['invalid'] = true;
            }
            else
            {
                if (null !== $this->_rules['decimal_places']
                    && preg_match('/\.([0-9]*)/', $value, $matches))
                {
                    if (strlen($matches[1]) > $this->_rules['decimal_places'])
                    {
                        $err['decimal_places_excided'] = true;
                    }
                }
                if (null !== $this->_rules['min_val']
                        && $value < $this->_rules['min_val'])
                {
                    $err['min_val_excided'] = true;
                }
                else if (null !== $this->_rules['max_val']
                        && $value > $this->_rules['max_val'])
                {
                    $err['max_val_excided'] = true;
                }
            }
        }
        return ($this->_errors($err, $value));
    }
}

/**
 * A date field. It stores the date only. You also might be interested in FTime and FTimestamp fields.
 */
class FDate extends Field
{
    public function __construct($name, $notnull = false, $def_val = null)
    {
        parent::__construct($name, $notnull, $def_val);
        $this->mess(array('invalid_format' => 'Invalid date format'));
    }

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] != 'date')
            $res['typename'] = $this->dbType();
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }


    /**
     *
     * @uses conf[locale][accepted date formats]
     */
    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else if ('NOW()' !== strtoupper($value))
        {
            if (!is_int($value)) // we allow to pass timestamp
            {
                if(false === strtotime($value))
                    $err['invalid'] = true;
            }

            if ($value && empty($err))
            {
                foreach (g()->conf['locale']['accepted date formats'] as $regex)
                {
                    if (!preg_match($regex, $value))
                    {
                        $err['invalid_format'] = true;
                        break;
                    }
                }
            }
        }

        return $this->_errors($err, $value);
    }

    public function dbType()
    {
        return ('DATE');
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else if ('NOW()' === strtoupper($value))
        {
            return 'NOW()';
        }
        else
        {
            if (!g('Functions')->isInt($value))
                $value = strtotime($value);
            // it's query-safe
            $value = date('Y-m-d', $value);
            return "'$value'";
        }
    }
}

class FMonthYear extends FDate
{
    public function dbString($value)
    {
        /*
        if(false !== ($av = @$this->autoValue()))
            return ($av);
         */
        if($value === null || $value === '')
            return 'NULL';
        if(!g('Functions')->isInt($value))
            $value = strtotime($value);
        $value = date('Y-m-01', $value);
        return "'$value'";
    }

    public function invalid(&$value)
    {
        $err = array();
        if(NULL != $value)
        {
            if (!is_int($value)) // we allow to pass timestamp
            {
                if(false === strtotime($value))
                    $err['invalid'] = true;
            }
        }
        elseif(!$this->autoValue($value) && $this->_rules['notnull'])
            $err['notnull'] = true;
        return ($this->_errors($err, $value));
    }
}

/**
 * A time field. It stroes the time of day only. You also might be interested in FDate and FTimestamp fields.
 */
class FTime extends Field
{

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] != 'time')
            $res['typename'] = $this->dbType();
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else if ('NOW()' !== strtoupper($value))
        {
            if (!is_int($value))
            {
                if(false === strtotime($value))
                    $err['invalid'] = true;
            }
        }
        return ($this->_errors($err, $value));
    }

    public function dbType()
    {
        return ('TIME');
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else if ('NOW()' === strtoupper($value))
        {
            return 'NOW()';
        }
        else
        {
            if (!g('Functions')->isInt($value))
                $value = strtotime($value);
            // it's query-safe
            $value = date('H:i:s', $value);
            return "'$value'";
        }
    }
}

/**
 * A timestamp field. It full date and time information. You also might be interested in FDate and FTime fields.
 */
class FTimestamp extends Field
{

    public function checkType($def)
    {
        // dbString() uppercases function names
        switch (strtoupper($def['defval']))
        {
            case 'NOW()' :
                $def['defval'] = strtoupper($def['defval']);
        }

        if (false === ($res = parent::checkType($def)))
            $res = array();

        if ($def['typename'] != 'timestamp')
            $res['typename'] = $this->dbType();

        if ($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();

        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else if ('NOW()' !== strtoupper($value))
        {
            $val = $value;
            if(!g('Functions')->isInt($value))
            {
                $val = strtotime($value);
                if(false === $val)
                    $err['invalid'] = true;
            }
        }
        return ($this->_errors($err, $value));
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else if ('NOW()' === strtoupper($value))
        {
            return 'NOW()';
        }
        else
        {
            if (!g('Functions')->isInt($value))
                $value = strtotime($value);
            // it's query-safe
            $value = date('Y-m-d H:i:s', $value);
            return "'$value'";
        }
    }

    public function dbType()
    {
        return ('TIMESTAMP');
    }
}

/**
 * A boolean field.
 */
class FBool extends Field implements IBoolean
{

    public function checkType($def)
    {
        if(false === ($res = parent::checkType($def)))
            $res = array();
        if($def['typename'] != 'bool')
            $res['typename'] = $this->dbType();
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType();
        return (empty($res) ? false : $res);
    }

    public function invalid(&$value)
    {
        $err = array();
        $val = $value;
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            if(null === ($val = g('Functions')->anyToBool($val)))
                $err['invalid'] = true;
        }
        return ($this->_errors($err, $value));
    }

    public function dbString($value)
    {
        if (null === $value || '' === $value)
        {
            return 'NULL';
        }
        else
        {
            return g('Functions')->anyToBool($value) ? 'true' : 'false';
        }
    }

    public function dbType()
    {
        return 'BOOL';
    }
}

/**
 * A table numeric ID type. That's represented in the database by type 'SERIAL'
 */
class FId extends Field
{

    /**
     * Constructor.
     * $name Field name.
     * $notnull The not null property.
     */
    public function __construct($name, $precision = 4, $not_null = true)
    {
        parent::__construct($name, $not_null);
        if(!in_array($precision, array(
            2,
            4,
            8
        )))
            $precison = 4;
        $this->_rules['precision'] = $precision;
        $this->auto(array($this, 'autoValueNextSeq'));
    }

    public function checkType($def)
    {
        $res = array();
        if($def['notnull'] != 't')
            $res['notnull'] = 't';
        if($def['defval'] != $this->defaultValue())
            $res['defval'] = $this->defaultValue();
        if($def['typename'] != 'int' && $def['typename'] != 'int' . $this->_rules['precision'])
            $res['typename'] = $this->dbType(false);
        if($def['type_specific'] != '-1')
            $res['typename'] = $this->dbType(false);
        return (empty($res) ? false : $res);
    }

    /**
     * Generates and possibly retrieves the default value of a SERIAL type. 
     * The default value in this case is the nextval of a specific sequencer. Exact default value is necessary to compare
     * the model declaration with the data base table definition (checkType()), however it can't be present in
     * the CREATE TABLE statement (Model::tableDefinition())
     * @param $def_val ignored unless a boolean true is given.
     * @return if $def_val is true, the string of form 'nextval(sequencer)' is returned, otherwise - an empty string is given.
     */
    public function defaultValue($def_val = true)
    {
        if(!isset($this->_rules['defval']))
            $this->_rules['defval'] = "nextval('" . $this->_model->getTableName() . "_{$this->_name}_seq'::regclass)";
        if($def_val === true)
            return $this->_rules['defval'];
        return '';
    }

    public function invalid(&$value)
    {
        $err = array();
        if (NULL === $value || '' === $value)
        {
            if ($this->notNull())
            {
                $err['notnull'] = true;
            }
        }
        else
        {
            if(!g('Functions')->isInt($value))
                $err['invalid'] = true;
        }
        return ($this->_errors($err, $value));
    }

    public function dbType($create = true)
    {
        if($create)
            return ('SERIAL');
        else
            switch($this->_rules['precision'])
            {
                case 2:
                    return ('INT2');
                break;
                case 4:
                    return ('INT4');
                break;
                case 8:
                    return ('INT8');
                break;
            }
    }


    /**
     * Callback used by autoValue to get next value from sequencer
     * @author m.augustynowicz
     */
    public function autoValueNextSeq($action, $field, & $value)
    {
        if ('insert' !== $action || null !== $value)
        {
            return null;
        }
        else
        {
            return $this->seqValue('next');
        }
    }

    public function seqValue($which = 'curr')
    {
        if($which !== 'curr' && $which !== 'next')
            throw new HgException('Which may only be "next" or "curr".');
        $seq_obj = $this->_model->getTableName() . "_{$this->_name}_seq";
        return (g()->db->GetOne("SELECT {$which}val('{$seq_obj}')"));
    }

    public function columnDefinition()
    {
        $sql = '"' . $this->getName() . '" ' . $this->dbType();

        if ($this->notNull())
        {
            $sql .= ' NOT NULL';
        }

        return $sql;
    }
}

/**
 * A foreign numeric id field.
 * Change name to FForeignId
 */
class FForeignId extends FInt
{
    protected $_foreign_model = '';

    /**
     * Constructor.
     * @param $name
     * @param $notnull
     * @param $foreign_model The NAME!! of the referenced model (not model object!)
     */
    public function __construct($name, $notnull = false, $foreign_model = '', $precision = 4)
    {
        parent::__construct($name, $precision, $notnull);
        if(!is_string($foreign_model))
            throw new HgException("Foreign model parameter has to be a string.");
        $this->foreignModel($foreign_model);
    }

    /**
     * Gets or sets the foreign model.
     */
    public function foreignModel($foreign_model = '')
    {
        if(empty($foreign_model))
            return ($this->_foreign_model);
        else
        {
            if(!is_string($foreign_model))
                throw new HgException("Foreign model parameter has to be a string.");
            else
                $this->_foreign_model = $foreign_model;
        }
    }
}

/**
 * Very special {@see FForeignId} for {@see UploadModel}
 *
 * @todo invalid() -- check type
 *
 * @author m.jutkiewicz
 * @author m.augustynowicz making it UserModel specific
 */
class FFile extends FString
{
    protected $_foreign_model = 'Upload';

    /**
     * @val array for supported values refer to UploadModel
     */
    protected $_conf = array();

    /**
     *
     * @param string $name
     * @param boolean $notnull add "NOT NULL"?
     * @param array $conf for supported values refer to UploadModel
     */
    public function __construct($name, $notnull = false, array $conf=array())
    {
        $this->_conf = array_merge($this->_conf, $conf);

        parent::__construct($name, $notnull, null, 0, 32);
    }

    /**
     * Gets the foreign model.
     */
    public function getModel()
    {
        if (is_string($this->_foreign_model))
        {
            $this->_foreign_model = g($this->_foreign_model, 'Model',
                    array('field'=>$this)
                );
        }
        return $this->_foreign_model;
    }

    /**
     * Settings getter
     *
     * @param string $property
     * @param mixed $value if specified, will check whether $value
     *        is present in requested config $property.
     *        NOTE: when $propety is true, it always return TRUE
     *
     * @return mixed when no $value specified, returns $value,
     *         boolean otherwise
     */
    public function getConf($property, $value=null)
    {
        if (func_num_args() == 1)
            return @ $this->_conf[$property];
        else
        {
            if (!isset($this->_conf[$property]))
                return null;
            else if (true === $this->_conf[$property])
                return true;
            else
                return isset($this->_conf[$property][$value]);
        }
    }


    /**
     * Get max file size
     *
     * Honours php settings.
     * @author m.augustynowicz
     *
     * @return int max file size, in bytes
     */
    public function getMaxSize()
    {
        $post_limit = $this->_humanSizeToBytes(ini_get('post_max_size'));
        $file_limit = $this->_humanSizeToBytes(ini_get('upload_max_filesize'));
        $mem_limit = $this->_humanSizeToBytes(ini_get('memory_limit'));
        $field_limit = $this->getConf('max size') * 1024;

        $limit = min($post_limit, $file_limit);

        if (-1 != $mem_limit)
        {
            $limit = min($limit, $mem_limit);
        }

        if (0 != $field_limit)
        {
            $limit = min($limit, $field_limit);
        }

        return $limit;
    }


    /**
     * Parse strings with M, G etc suffixes to integers.
     * @author m.augustynowicz
     *
     * @param string $size
     * @return bool|int false on any error
     */
    protected function _humanSizeToBytes($size)
    {
        if (!preg_match('/^\s*(-?[0-9]+)\s*(.*)?$/', $size, $matches))
        {
            return false;
        }

        $size = $matches[1];
        $unit = @$matches[2];
        switch (strtoupper($unit))
        {
            case 'PB' :
            case 'P' :
                $size *= 1024;
            case 'TB' :
            case 'T' :
                $size *= 1024;
            case 'GB' :
            case 'G' :
                $size *= 1024;
            case 'MB' :
            case 'M' :
                $size *= 1024;
            case 'KB' :
            case 'K' :
                $size *= 1024;
        }
        return $size;
    }

    /**
     * Invalidate file field
     * @author j.rozanski
     * @param not_known $value uploaded file array or md5 string
     */
    public function invalid(&$value)
    {
        $err = array();
        if(is_array($value))
        {
            if($value['error'] != UPLOAD_ERR_OK)
            {
                if($value['error'] == UPLOAD_ERR_NO_FILE)
                {
                    if($this->notNull())
                        $err['notnull'] = true;
                }
                else
                    $err['invalid'] = true;
            }
        }
        elseif(is_string($value))
        {
            // store max and min length as they are meant to be used as foregin key

            $prev_rules = array(
                'min_length' => $this->_rules['min_length'],
                'max_length' => $this->_rules['max_length']
            );
            $this->_rules['min_length'] = $this->_rules['max_length'] = null;

            $return = parent::invalid($value);

            $this->_rules = array_merge(
                $this->_rules,
                $prev_rules
            );

            return $return;
        }
        return ($this->_errors($err, $value));
    }
}

/**
 * Very special FForeignId for ImagesUploadModel
 * @author m.augustynowicz
 */
class FImageFile extends FFile
{
    protected $_foreign_model = 'ImagesUpload';
}

/**
 * Very special FForeignId for MediaUploadModel
 * @author m.augustynowicz
 */
class FMediaFile extends FFile
{
    protected $_foreign_model = 'MediaUpload';

    /**
     * @val array for supported values refer to MediaUploadModel (and up)
     */
    protected $_conf = array();

}

/**
 * Fields that evaluate a function.
 */
class FoFunc extends FAnyType implements IEvalField
{
    protected $_call_args;
    protected $_definition;
    /**
     * Definitions of recognized functions. Definition syntax is similar to the one used
     * in PostgreSQL manual. The 'res' key in each definition stores the return type. Numerical
     * keys store different variants of the function. Stuff in the square backets is optional.
     * The match() function looks for definition that matches arguments given by a user.
     */
    static $functions = array(
        'length' => array(
            'res' => 'FInt',
            'char_length($string:FString)'
        ),
        'lower' => array(
            'res' => 'FInt',
            'lower($string:FString)'
        ),
        'upper' => array(
            'res' => 'FInt',
            'upper($string:FString)'
        ),
        'substr' => array(
            'res' => 'FString',
            'substring($string:FString[ from $from:FInt][ for $for:FInt])',
            'substring($string:FString from $pattern:FString)',
            'substring($string:FString from $pattern:FString for $escape:FString)'
        ),
        'trim_both' => array(
            'res' => 'FString',
            'trim(both[ $characters:FString] from $string:FString)'
        ),
        'trim_leading' => array(
            'res' => 'FString',
            'trim(leading[ $characters:FString] from $string:FString)'
        ),
        'trim_trailing' => array(
            'res' => 'FString',
            'trim(trailing[ $characters:FString] from $string:FString)'
        ),
        'random' => array(
            'res' => 'FFloat',
            'random()'
        ),
        'max' => array(
            'res' => 'FString',
            'MAX($int:FInt)',
            'MAX($int:FBool)',
            'MAX($int:FString)',
            'MAX($int:FTimestamp)'
        ),
        'count' => array(
            'res' => 'FString',
            'COUNT($int:FId)',
            'COUNT($int:FInt)',
            'COUNT($int:FBool)',
            'COUNT($int:FString)',
            'COUNT($int:FTimestamp)'
        ),
        'count distinct' => array(
            'res' => 'FString',
            'COUNT(DISTINCT $int:FId)',
            'COUNT(DISTINCT $int:FInt)',
            'COUNT(DISTINCT $int:FBool)',
            'COUNT(DISTINCT $int:FString)',
            'COUNT(DISTINCT $int:FTimestamp)'
        ),
        'sum' => array(
            'res' => 'FInt',
            'SUM($int:FInt)',
            'SUM(CAST($int:FBool AS int))',
        ),        
        'avg' => array(
            'res' => 'FInt',
            'AVG($int:FInt)',
        ),        
        
    );

    /**
     * Looks for a function definition that best matches given argument set. 
     * @param $args array of call arguments. $args[0] contains the name of a function.
     */
    public function match($args)
    {
        $func = strtolower(array_shift($args));
        if(!array_key_exists($func, self::$functions))
            throw new HgException("No such function '$func'");
        $func = self::$functions[$func];
        $call_args = array();
        foreach($args as $param)
        {
            if(NULL === $param || $param instanceof IField)
                $call_args[] = $param;
            else
                $call_args[] = FAnyType::factory($param);
        }
        foreach($func as $k => $definition)
        {
            if(!is_int($k))
                continue;
            $vars = array();
            if(preg_match_all('/(\$[a-z]+):([A-Za-z|]+)/', $definition, $regs))
                $vars = array_combine($regs[1], $regs[2]);
            $opt_vars = array();
            if(preg_match_all('/\[.*(\$[a-z]+):.*\]/U', $definition, $regs))
                $opt_vars = array_combine($regs[1], $regs[0]);
            $def = reset($vars);
            $empty_opt_vars = array(); //keeps all optional args that were used
            foreach($call_args as &$call_arg)
            {
                $key = key($vars);
                if(FALSE === $def)
                    continue (2); //to many call args for this def
                if(NULL === $call_arg)
                {
                    if(!isset($opt_vars[$key]))
                        continue (2); //trying to pass an argument that is not optional in this def.
                    //var_dump("good, passing optional argument $key");
                    $empty_opt_vars[] = $key;
                    continue;
                }
                if(!$call_arg->type($def))
                    continue (2); //invalid arg type for this def
                $def = next($vars);
            }
            if(!empty($call_args))
                $call_args = array_filter(array_combine(array_keys($vars), $call_args));
                //var_dump($opt_vars);
            //var_dump(array_intersect_key($opt_vars,array_flip($empty_opt_vars)));
            $definition = str_replace(array_intersect_key($opt_vars, array_flip($empty_opt_vars)), '', $definition);
            $definition = preg_replace('/(:[A-Za-z|]+)|\]|\[/', '', $definition);
            $this->_definition = $definition;
            $this->_call_args = $call_args;
            $this->_genType = $func['res'];
            //var_dump(compact('call_args','definition'));
            break;
        }
    }

    /**
     * Constructor
     * @param $function_name 
     * @param ... Function parameters. 
     */
    public function __construct($function_name)
    {
        $this->match(func_get_args());
    }

    public function generator()
    {
        $replacements = array();
        if(!empty($this->_call_args))
        {
            foreach($this->_call_args as &$arg)
                $replacements[] = $arg->generator();
            return (str_replace(array_keys($this->_call_args), $replacements, $this->_definition));
        }
        return ($this->_definition);
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * Field that evaluates a chain of operators. I. e. $arg1 AND $arg2 AND $arg3 [...].
 * All args need to have compatibile generator types.
 */
class FoChain extends FAnyType implements IEvalField
{
    protected $_operands = array();
    protected $_glue = '?';

    /**
     * Constructor. Requires first two links of the chain. One can add other links with subsequent calls to also().
     * @param $arg_1 The first argument
     * @param $operator operator, currently one of: 'and','or','||'.
     * @param @arg_2 The second argument.
     */
    public function __construct($arg_1, $operator, $arg_2)
    {
        //$args = func_get_args();
        switch(strtolower($operator))
        {
            case 'and':
            case 'or':
                $this->_genType = 'IBoolean';
            break;
            case '||':
                $this->_genType = 'FString';
            default:
                throw new HgException("operator $operator is not supported");
        }
        $this->_glue = $operator;
        if(empty($arg_1) || empty($arg_2))
            throw new HgException("Cannot pass empty operands to the FoChain constructor");
        $this->also($arg_1);
        $this->also($arg_2);
    }

    /**
     * Adds more links to a chain
     * @param $operand A operand to link  with the existing chain.
     * FIXME: more flexible arguments. Accept var arg or an array.
     */
    public function also($operand)
    {
        if(NULL === $operand)
            return ($this);
        if(is_string($operand))
            $this->_operands[] = new FoStatement($operand, $this->_genType);
        elseif($operand instanceof IField) // && $operand->type($this->_genType))
            $this->_operands[] = $operand;
        else
        {
            var_dump(array(
                'this' => $this,
                'invalid_operand' => $operand,
                'type' => $operand->type($this->_genType)
            ));
            throw new HgException("An operand may only be a string or an IField.");
        }
        return ($this);
    }

    /**
     * 
     */
    public function generator()
    {
        $curr = reset($this->_operands);
        $res = '';
        if($curr)
            $res .= $curr->generator();
            //else //var_dump($this);
        while($curr = next($this->_operands))
            $res .= "\n{$this->_glue}    " . $curr->generator();
        return ($res);
    }

    /**
     * @author m.augustynowicz
     */
    public function __toString() {
        return $this->generator();
    }
}

/**
 * Copy/Paste from FoChain - differencec
 *     1. implements IBoolean
 *     2. does not accept '||'' as operator  
 * Field that evaluates a chain of operators. I. e. $arg1 AND $arg2 AND $arg3 [...].
 * All args need to have compatibile generator types.
 */
class FoBinaryChain extends FoChain implements IBoolean
{
    /**
     * Constructor. Requires first two links of the chain. One can add other links with subsequent calls to also().
     * @param $arg_1 The first argument
     * @param $operator operator, currently one of: 'and','or'.
     * @param @arg_2 The second argument.
     */
    public function __construct($arg_1, $operator, $arg_2)
    {
        //$args = func_get_args();
        switch(strtoupper($operator))
        {
            case 'AND':
            case 'OR':
                $this->_genType = 'IBoolean';
            break;
            default:
                throw new HgException("operator $operator is not supported");
        }
        $this->_glue = strtoupper($operator);
        if(empty($arg_1) || empty($arg_2))
            throw new HgException("Cannot pass empty operands to the FoChain constructor");
        $this->also($arg_1);
        $this->also($arg_2);
    }

    /**
     * Adds more links to a chain
     * @param $operand A operand to link  with the existing chain.
     * FIXME: more flexible arguments. Accept var arg or an array.
     */
    public function also($operand)
    {
        if(NULL === $operand)
            return ($this);
        if(is_string($operand))
            $this->_operands[] = new FoStatement($operand, $this->_genType);
        elseif($operand instanceof IField) // && $operand->type($this->_genType))
            $this->_operands[] = $operand;
        else
        {
            var_dump(array(
                'this' => $this,
                'invalid_operand' => $operand,
                'type' => $operand->type($this->_genType)
            ));
            throw new HgException("An operand may only be a string or an IField.");
        }
        return ($this);
    }

    /**
     * 
     */
    public function generator()
    {
        $curr = reset($this->_operands);
        $res = "(\n";
        if($curr)
            $res .= $curr->generator();
        while($curr = next($this->_operands))
            $res .= "\n{$this->_glue}\n" . $curr->generator();
        $res = str_replace("\n", "\n  ", $res);
        $res .= "\n)";
        return ($res);
    }
}

/**
 * A binary operator field.
 */
class FoBinary extends FCustomBoolean implements IEvalField, IBoolean
{
    protected $_left, $_right, $_operator;

    /**
     * Constructor.
     * @param $left Left operand
     * @param $operator string with an operator, either of '<','>','=','>=','<=','<>','like','ilike'
     * @param $right Right operand.
     * @param $type type of the operands if both $left and $right are provied as strings.
     */
    public function __construct($left, $operator, $right, $type = false)
    {
        $operator = strtoupper($operator);
        if(!in_array($operator, array(
            '<',
            '>',
            '=',
            '>=',
            '<=',
            '<>',
            '!=',
            'LIKE',
            'ILIKE'
        )))
            throw new HgException("Unsupported operator $operator");
        if($left instanceof IField)
            $type = $left->type();
        elseif($right instanceof IField)
            $type = $right->type();
        if(!$type)
            throw new HgException("Either left or right have to be IFields, or type has to be passed explicitly");
        if(!$left instanceof IField)
            $left = new FoStatement($left, $type);
        if(!$right instanceof IField)
            $right = new FoStatement($right, $type);
        $this->_left = $left;
        $this->_operator = $operator;
        $this->_right = $right;
    }

    public function generator()
    {
        return ($this->_left->generator() . " {$this->_operator} " . $this->_right->generator());
    }
}

/*

class FoSubquery extends DataSet implements IField
{
    public function execute()    
    {
        $this->whiteList(array_key($this->_fields));
        $this->setMargins(0,1);
        return(arent::execute());
    }
    
}
*/
/**
 * A sql statement field. This field can be used to directly paste a string statement into the query. The statement
 * may refer to some named arguments, for which other IFields may be used.
 */
class FoStatement extends FAnyType implements IEvalField, IField
{
    protected $_statement;
    protected $_args = NULL;
    protected $_var_sign = '$';

    /**
     * Constructor.
     * @param $statement The statement string, possibly with embedded arguments.
     * @param $type Type of the statement.
     * @param $args an array of arguments. Every argument used in the statement has to be used. 
     * @param $var_sign a variable begin and end sign. Typically a single dollar is used making each apperiance of
     *     $identifier$ in the statemenr refer to a variable named identifier, that has to be passed in $args array
     * @example
     *     $f = new FoStatement(
     *         '$number$ + $number$ / 17 + $func$',
     *          'FInt',
     *          array (
     *              'number' => new FConst('5','FInt'),
     *              'func' => new FoFunc('length',new FConst("foofoo", 'FString'))
     *          )
     *      );
     *      var_dump($f->generator());    
     *      //returns '5 + 5 / 17 + char_length('foofoo')'
     */
    public function __construct($statement, $type, $args = array(), $var_sign = '$')
    {
        $this->_statement = $statement;
        $this->_args = $args;
        $this->_var_sign = $var_sign;
        $this->_iField($type);
        $this->_genType = $type;
    }

    public function generator()
    {
        if(empty($this->_args))
            return ($this->_statement);
        $values = array();
        $s_len = strlen($this->_var_sign);
        $offset = 0;
        $res = '';
        //var_dump($this->_statement);
        while(FALSE !== ($pos = strpos($this->_statement, $this->_var_sign, $offset)))
        {
            if(FALSE === ($var_end = strpos($this->_statement, $this->_var_sign, $pos + $s_len)))
                throw new HgException('Variable end not found');
            $var = substr($this->_statement, $pos + $s_len, $var_end - $pos - $s_len);
            //var_dump(compact('pos','var_end','var','offset'));            
            if(!isset($values[$var]))
                $values[$var] = ($this->_args[$var] instanceof IField ? $this->_args[$var]->generator() : $this->_args[$var]);
            $res .= substr($this->_statement, $offset, $pos - $offset) . $values[$var];
            $offset = $var_end + $s_len;
            //var_dump(compact('res','offset'));            
        }
        return ($res);
    }

    /**
     * Checks if given type is an IField. 
     * This is by default an assertion-level function, when the result is bad, it throws)
     */
    protected function _iField($type, $fail = true)
    {
        if('IField' == $type || in_array('IField', class_implements($type)))
            return true;
        if($fail)
            throw new HgException('$type must be a class that implements IField.');
        return (false);
    }
}
